<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Chat de consultas geogr√°ficas (por opciones)</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<style>
  :root{
    --bg:#06150f; --panel:#0b2018; --ink:#e6f4ef; --muted:#9bb3a9; --accent:#0a784f; --accent-ink:#0a5e41;
    --chip:#103524; --border:#153c2a; --warn:#eab308; --err:#ef4444; --ok:#17c964;
  }
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--ink); font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;}
  .app{display:grid; grid-template-columns:1fr; min-height:100vh}

  header{border-bottom:1px solid var(--border); background:linear-gradient(180deg, rgba(10,120,79,.18), rgba(10,120,79,0));}
  .wrap{max-width:960px; margin:0 auto; padding:14px 16px}
  h1{margin:0; font-size:clamp(18px, 4vw, 22px)}
  .tag{color:var(--muted); font-size:13px}

  .main{display:grid; grid-template-columns:1fr; gap:14px; padding:12px 0}

  /* Chat */
  .chat{max-width:960px; margin:0 auto; display:grid; gap:12px; padding: 0 16px 52px}
  .msg{display:flex; gap:10px}
  .msg.bot{justify-content:flex-start}
  .msg.user{justify-content:flex-end}
  .bubble{background:var(--panel); border:1px solid var(--border); padding:12px 14px; border-radius:14px; max-width:min(720px, 84vw);}
  .bubble.bot{border-top-left-radius:6px}
  .bubble.user{background:#0a5e41; border-color:transparent; border-bottom-right-radius:6px}
  .opts{display:flex; flex-wrap:wrap; gap:8px; margin-top:10px}
  .opt{appearance:none; background:var(--accent); border:none; color:#fff; padding:8px 12px; border-radius:999px; cursor:pointer; font-weight:600;}
  .opt.secondary{background:transparent; color:#d1efe4; border:1px solid var(--border)}

  .inline{display:flex; gap:8px; margin-top:8px; flex-wrap:wrap}
  .inline input{flex:1; min-width:220px; padding:10px 12px; border-radius:12px; border:1px solid var(--border); background:#08170f; color:#fff}
  .inline button{padding:10px 12px; border-radius:12px; border:1px solid var(--border); background:var(--accent); color:#fff; cursor:pointer}

  .hint{font-size:12px; color:var(--muted); margin-top:6px}
  .small{font-size:12px; color:var(--muted)}
  .badge{display:inline-block; padding:2px 8px; border-radius:999px; font-size:11px; border:1px solid var(--border); background:#0b2418; margin-left:6px}
  .badge.ok{border-color:#135a3d; color:#b9f3dd}
  .badge.backup{border-color:#8b6d2a; color:#f7e7b0}
  .badge.zero{border-color:#2e3d36; color:#cbd8d3}
  .badge.down{border-color:#6b1f1f; color:#ffdbdb}

  /* Mapa (oculto hasta tener punto + categor√≠a) */
  .map-wrap{max-width:1100px; margin:0 auto; padding: 0 16px 22px; display:none}
  .map-tools{display:flex; align-items:center; gap:10px; margin:10px 0; flex-wrap:wrap}
  .btn{background:transparent; border:1px solid var(--border); color:#d7eee6; padding:8px 10px; border-radius:10px; font-size:13px; text-decoration:none; cursor:pointer}
  .btn.primary{background:var(--accent-ink); color:white; border-color:transparent}
  #map{height:58vh; border:1px solid var(--border); border-radius:14px}

  details{background:#0b2418; border:1px solid var(--border); border-radius:12px; padding:8px 10px; margin:8px 0}
  details>summary{cursor:pointer; font-weight:600}
  table{width:100%; border-collapse:collapse; margin-top:6px; font-size:13px}
  td{border-top:1px dashed var(--border); padding:6px; vertical-align:top}
  td:first-child{color:#b7d1c7; width:40%}

  .error{background:#230b0b; border:1px solid #501c1c; color:#ffdddd; padding:10px 12px; border-radius:12px}

  /* Burbuja fija de refresco total */
  .refresh-fab{position:fixed; right:16px; bottom:16px; z-index:9999}
  .refresh-fab button{background:#0a5e41; color:#fff; border:none; border-radius:999px; padding:10px 14px; box-shadow:0 6px 18px rgba(0,0,0,.35); cursor:pointer; font-weight:700}

  /* Lista de capas consultadas / toggles */
  .layers-list{display:flex; flex-wrap:wrap; gap:8px; margin:6px 0}
  .layer-chip{display:flex; align-items:center; gap:6px; border:1px solid var(--border); border-radius:999px; padding:4px 8px; background:#0b2418}
  .layer-chip input{accent-color:#0a784f}
</style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Consultas geogr√°ficas (chat por opciones)</h1>
      <div class="tag">Se ofrecen solo categor√≠as con REST/REST de respaldo (tabla p√∫blica)</div>
    </div>
  </header>

  <main class="main">
    <section class="chat" id="chat" aria-live="polite"></section>

    <section class="map-wrap" id="mapWrap" aria-label="Resultados y mapa">
      <div class="map-tools">
        <button class="btn" id="btnBackToPoint">‚ü≤ Volver a elegir punto</button>
        <button class="btn" id="btnBackToCategory">‚ü≤ Cambiar categor√≠a</button>
        <button class="btn" id="btnRefresh">Refrescar consulta</button>
        <span class="small" id="mapStatus">‚Äî</span>
      </div>
      <div id="map" role="application" aria-label="Mapa"></div>

      <!-- Panel de capas consultadas/toggles -->
      <div id="layerToggles" class="layers-list" aria-label="Capas consultadas"></div>

      <!-- Resultados -->
      <div id="results" style="margin-top:10px"></div>

      <!-- Buscar cerca -->
      <div id="nearbyBox" style="margin-top:12px; display:none">
        <details open>
          <summary>üîç Buscar zonas cerca (radio configurable)</summary>
          <div class="inline">
            <label class="small" for="radiusKm">Radio (km, por defecto 10):</label>
            <input id="radiusKm" type="number" min="1" max="200" step="1" value="10"/>
            <button id="btnNearby" class="btn primary">Buscar cerca</button>
            <span class="small" id="nearbyStatus">‚Äî</span>
          </div>
        </details>
      </div>
    </section>
  </main>

  <!-- Burbuja fija para refrescar TODO el chat -->
  <div class="refresh-fab"><button id="fabRefresh">‚ü≥ Refrescar chat</button></div>

<script>
/* ===== Config ===== */
const CSV_URL = 'https://docs.google.com/spreadsheets/d/1Smop4rx0K4pj5sHXD19DE3iqcwTCyqn9ohPxIuJsZ8s/export?format=csv&gid=0';
const CO_VIEWBOX = '-79.1,12.6,-66.8,-4.3';

/* ===== State ===== */
const STATE = {
  catalog: [],
  categories: [],
  step: 0,            // 0: pedir m√©todo para punto; 1: punto fijado; 2: elegir categor√≠a; 3: consultar/mostrar
  point: null,        // {lat,lng}
  category: null,
  map: null,
  marker: null,
  drawn: {},          // layerId -> L.GeoJSON
  defs: [],           // definiciones de capas en la categor√≠a
  lastMode: 'point'   // 'point' | 'nearby'
};

/* ===== Utils ===== */
const deaccent = s => (s||'').normalize('NFD').replace(/\p{Diacritic}/gu,'');
const byId = id => document.getElementById(id);
function el(tag, attrs={}, html=''){ const n=document.createElement(tag); Object.assign(n, attrs); if(html!==undefined) n.innerHTML=html; return n; }
function scrollChat(){ const c=byId('chat'); c.scrollTop = c.scrollHeight; }
function addBot(text){ const row=el('div',{className:'msg bot'}); row.appendChild(el('div',{className:'bubble bot'}, text)); byId('chat').appendChild(row); scrollChat(); return row; }
function addUser(text){ const row=el('div',{className:'msg user'}); row.appendChild(el('div',{className:'bubble user'}, text)); byId('chat').appendChild(row); scrollChat(); }
function clearChat(){ byId('chat').innerHTML=''; }

function normalizeRecord(rec){
  const out={};
  for(const [k,v] of Object.entries(rec)){
    const key = deaccent(String(k).trim().toLowerCase()).replace(/\s+/g,'_').replace(/[^a-z0-9_]/g,'');
    out[key] = (v==null) ? '' : String(v).trim();
  }
  out.titulo       = out.titulo || out.title || '';
  out.descripcion  = out.descripcion || out.description || '';
  out.categoria    = out.categoria || out.categoria_ || out['categor_a'] || '';
  out.rest         = out.rest || '';
  out.rest_respaldo= out['rest_de_respaldo'] || out['rest_respaldo'] || '';
  out.origen       = out.origen || out.fuente || '';
  out.acceso       = out.acceso || '';
  return out;
}

async function loadCatalog(){
  return new Promise((resolve,reject)=>{
    Papa.parse(CSV_URL,{download:true, header:true, skipEmptyLines:true,
      complete:(res)=>{ try{ STATE.catalog = res.data.map(normalizeRecord); resolve(STATE.catalog);}catch(e){reject(e)} },
      error:(e)=>reject(e)
    });
  });
}

function computeCategories(){
  const ok = STATE.catalog.filter(r=> (r.rest && r.rest.length>6) || (r.rest_respaldo && r.rest_respaldo.length>6));
  const set = new Set(ok.map(r=>r.categoria).filter(Boolean));
  STATE.categories = Array.from(set).sort((a,b)=>a.localeCompare(b,'es',{sensitivity:'base'}));
}

/* ===== Mapa ===== */
function ensureMap(){
  // Mostrar mapa SOLO cuando hay punto + categor√≠a (estructura √°rbol)
  const wrap = byId('mapWrap');
  if(STATE.point && STATE.category){ wrap.style.display='block'; } else { wrap.style.display='none'; }
  if(STATE.map) return STATE.map;
  STATE.map = L.map('map',{zoomControl:true, minZoom:3}).setView([3.9,-73.1], 5);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'&copy; OpenStreetMap contrib.'}).addTo(STATE.map);
  return STATE.map;
}

function setMarker(ll){
  if(!STATE.point || !STATE.category) return; // respeta el √°rbol
  ensureMap();
  if(STATE.marker){ STATE.map.removeLayer(STATE.marker); }
  STATE.marker = L.marker(ll).addTo(STATE.map);
  STATE.map.setView(ll, 12);
}

function clearDrawn(){
  Object.values(STATE.drawn).forEach(layer=>{ if(STATE.map && STATE.map.hasLayer(layer)) STATE.map.removeLayer(layer); });
  STATE.drawn = {};
  byId('layerToggles').innerHTML = '';
}

/* ===== Flujo y rebobinado ===== */
function goToStep(step){
  STATE.step = step;
  clearChat();
  if(step===0) renderStep0();
  if(step>=1){ renderStep0(true); renderStep1(); }
  if(step>=2){ renderStep2(); }
  if(step>=3){ renderStep3(); }
}

function renderStep0(skipIntro=false){
  if(!skipIntro){ addBot('<b>Hola.</b> Primero, define el punto para consultar.'); }
  const row = addBot('Elige una opci√≥n:');
  const opts = el('div',{className:'opts'});
  const b1 = el('button',{className:'opt'},'üìç Usar mi ubicaci√≥n');
  const b2 = el('button',{className:'opt secondary'},'üîé Buscar con OSM');
  const b3 = el('button',{className:'opt secondary'},'‚å®Ô∏è Ingresar coordenadas');
  opts.append(b1,b2,b3); row.querySelector('.bubble').appendChild(opts);
  b1.onclick = handleUseMyLocation;
  b2.onclick = handleOSMSearch;
  b3.onclick = handleCoordsInput;
}

function renderStep1(){
  if(!STATE.point){ return; }
  addUser(`Ubicaci√≥n establecida: ${STATE.point.lat.toFixed(5)}, ${STATE.point.lng.toFixed(5)}`);
  // NO mostrar mapa a√∫n (se muestra en step 3 con categor√≠a seleccionada)
}

function renderStep2(){
  const available = STATE.categories.slice();
  if(!available.length){ addBot('<span class="error">No hay categor√≠as con REST disponible en la tabla.</span>'); return; }
  const row = addBot('Ahora elige la <b>categor√≠a de consulta</b>:');
  const opts = el('div',{className:'opts'});
  available.forEach(cat=>{
    const b = el('button',{className:'opt'}, cat);
    b.onclick = ()=>{ STATE.category = cat; addUser(cat); goToStep(3); runQueryPoint(); };
    opts.appendChild(b);
  });
  row.querySelector('.bubble').appendChild(opts);
}

function renderStep3(){
  ensureMap(); // ahora s√≠, punto+categor√≠a est√°n definidos
  byId('mapStatus').textContent = 'Consultando intersecci√≥n puntual‚Ä¶';
}

/* ===== Entrada de punto ===== */
function handleUseMyLocation(){
  addUser('Usar mi ubicaci√≥n');
  if(!navigator.geolocation){ addBot('<span class="error">Tu navegador no permite geolocalizaci√≥n.</span>'); return; }
  addBot('Obteniendo tu ubicaci√≥n‚Ä¶');
  navigator.geolocation.getCurrentPosition((pos)=>{
    STATE.point = {lat:pos.coords.latitude, lng:pos.coords.longitude};
    goToStep(1); renderStep2();
  }, (err)=>{ addBot(`<span class=\"error\">No se pudo obtener ubicaci√≥n: ${err.message}</span>`); });
}

function handleOSMSearch(){
  const row = addBot('Escribe un lugar o direcci√≥n en Colombia.');
  const box = el('div',{className:'inline'});
  const inp = el('input',{type:'text', placeholder:'Cra 7 # 12-34, Bogot√°‚Ä¶ o ‚ÄúParque Arv√≠‚Äù'});
  const btn = el('button',{},'Buscar');
  box.append(inp,btn); row.querySelector('.bubble').appendChild(box);
  btn.onclick=()=> doOSMSearch(inp.value);
  inp.addEventListener('keydown',(e)=>{ if(e.key==='Enter') doOSMSearch(inp.value); });
}

async function doOSMSearch(q){
  const text = (q||'').trim(); if(!text) return;
  addUser(text);
  try{
    const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&q=${encodeURIComponent(text)}&addressdetails=1&limit=5&countrycodes=co&viewbox=${CO_VIEWBOX}&bounded=1`;
    const res = await fetch(url, {headers:{'Accept':'application/json'}});
    if(!res.ok) throw new Error('Sin respuesta de Nominatim');
    const items = await res.json();
    if(!items.length){ addBot('Sin resultados en Colombia para esa b√∫squeda.'); return; }
    if(items.length===1){
      const it = items[0];
      STATE.point = {lat:parseFloat(it.lat), lng:parseFloat(it.lon)};
      goToStep(1); renderStep2();
    } else {
      const row = addBot('Selecciona el resultado correcto:');
      const opts = el('div',{className:'opts'});
      items.forEach(it=>{
        const b = el('button',{className:'opt secondary'}, it.display_name.slice(0,64)+'‚Ä¶');
        b.onclick = ()=>{ STATE.point = {lat:parseFloat(it.lat), lng:parseFloat(it.lon)}; goToStep(1); renderStep2(); };
        opts.appendChild(b);
      });
      row.querySelector('.bubble').appendChild(opts);
    }
  }catch(e){ addBot(`<span class=\"error\">Error buscando: ${e.message}</span>`); }
}

function handleCoordsInput(){
  const row = addBot('Ingresa coordenadas (lat, lng). Ej: 4.7110, -74.0721');
  const box = el('div',{className:'inline'});
  const inp = el('input',{type:'text', placeholder:'lat, lng'});
  const btn = el('button',{},'Usar');
  box.append(inp,btn); row.querySelector('.bubble').appendChild(box);
  btn.onclick = ()=>{
    const parts = (inp.value||'').split(',').map(x=>parseFloat(x.trim()));
    if(parts.length===2 && parts.every(x=>!isNaN(x))){
      STATE.point = {lat:parts[0], lng:parts[1]};
      goToStep(1); renderStep2();
    } else {
      addBot('<span class="error">Formato inv√°lido. Usa: lat, lng</span>');
    }
  };
}

/* ===== REST helpers ===== */
function urlWithParams(base, params){
  const u = new URL(base);
  Object.entries(params).forEach(([k,v])=> u.searchParams.set(k,String(v)));
  return u.toString();
}

async function fetchJson(u, extra={}){
  const url = u.includes('?') ? `${u}&f=json` : `${u}?f=json`;
  const ctrl = new AbortController();
  const t = setTimeout(()=>ctrl.abort('timeout'), 12000);
  try{
    const res = await fetch(url, {signal:ctrl.signal, ...extra});
    clearTimeout(t);
    if(!res.ok) throw new Error('HTTP '+res.status);
    return await res.json();
  }catch(e){ clearTimeout(t); return {error:String(e)}; }
}

function isMapServerRoot(info){ return info && info.currentVersion && Array.isArray(info.layers) && !info.type; }

async function expandToFeatureLayers(url){
  const info = await fetchJson(url);
  if(info.error) return {error:info.error, layers:[]};
  if(isMapServerRoot(info)){
    const layers = (info.layers||[]).filter(l=> !l.subLayerIds || !l.subLayerIds.length);
    return {layers: layers.map(l=> `${url.replace(/\/?$/,'')}/${l.id}`)};
  }
  return {layers:[url]};
}

async function queryLayer(layerUrl, point, distanceMeters){
  const info = await fetchJson(layerUrl);
  if(info.error) return {error:'Servicio no disponible', layerUrl};

  const base = {
    where: '1=1', f:'json', returnGeometry:true, outFields:'*',
    geometry: JSON.stringify({x:point.lng, y:point.lat, spatialReference:{wkid:4326}}),
    geometryType: 'esriGeometryPoint', spatialRel:'esriSpatialRelIntersects',
    inSR:4326, outSR:4326
  };
  const params = distanceMeters ? {...base, distance:distanceMeters, units:'esriSRUnit_Meter'} : base;
  const queryUrl = layerUrl.replace(/\/?$/,'') + '/query';
  const u = urlWithParams(queryUrl, params);
  const js = await fetchJson(u);
  if(js.error || js.code){ return {error: js.error? String(js.error): ('HTTP '+js.code)}; }
  const feats = Array.isArray(js.features)? js.features: [];
  return {features:feats};
}

function getDefsForCategory(cat){
  const rows = STATE.catalog.filter(r=> r.categoria===cat && ((r.rest && r.rest.length>6) || (r.rest_respaldo && r.rest_respaldo.length>6)));
  return rows.map((r,i)=> ({
    id:`${deaccent(cat.toLowerCase()).replace(/[^a-z0-9]/g,'_')}_${i}`,
    name:r.titulo||r.descripcion||r.origen||`Capa ${i+1}`,
    primary:r.rest, backup:r.rest_respaldo,
    acceso:r.acceso, descripcion:r.descripcion
  }));
}

/* ===== Consultas ===== */
async function runQueryPoint(){
  if(!STATE.point || !STATE.category){ addBot('<span class="error">Faltan datos (punto y categor√≠a).</span>'); return; }
  STATE.lastMode = 'point';
  clearDrawn();
  byId('results').innerHTML = '';
  byId('mapStatus').textContent = 'Consultando intersecci√≥n puntual‚Ä¶';
  byId('nearbyBox').style.display = 'block'; // ofrecer luego ‚Äúbuscar cerca‚Äù
  ensureMap(); setMarker(STATE.point);

  STATE.defs = getDefsForCategory(STATE.category);
  if(!STATE.defs.length){ addBot('<span class="error">No hay capas con REST en esta categor√≠a.</span>'); return; }

  addBot('Consultando servicios de la categor√≠a seleccionada‚Ä¶');
  const layerStatuses = [];
  const results = [];

  for(const def of STATE.defs){
    addBot(`Consultando <b>${def.name}</b>‚Ä¶`);
    // expandir si es ra√≠z
    const expanded = await expandToFeatureLayers(def.primary);
    const targetLayers = expanded.layers.length ? expanded.layers : [def.primary];

    let foundFeatures = [];
    let usedBackup = false;
    let anyError = false;

    // intentar primaria (todas las subcapas)
    for(const lyr of targetLayers){
      const r = await queryLayer(lyr, STATE.point, null);
      if(r.error){ anyError = true; continue; }
      if(r.features && r.features.length){ foundFeatures = foundFeatures.concat(r.features.map(ft => ({...ft, _layerUrl: lyr}))); }
    }

    // si primaria fall√≥ totalmente o no dio intersecciones y hay respaldo ‚Üí intentar respaldo
    if((!foundFeatures.length || anyError) && def.backup){
      addBot(`La capa principal no respondi√≥ o no intersect√≥. Intentando respaldo para <b>${def.name}</b>‚Ä¶`);
      const expB = await expandToFeatureLayers(def.backup);
      const bLayers = expB.layers.length ? expB.layers : [def.backup];
      usedBackup = true;
      anyError = false;
      foundFeatures = [];
      for(const lyr of bLayers){
        const r = await queryLayer(lyr, STATE.point, null);
        if(r.error){ anyError = true; continue; }
        if(r.features && r.features.length){ foundFeatures = foundFeatures.concat(r.features.map(ft => ({...ft, _layerUrl: lyr}))); }
      }
    }

    const status = foundFeatures.length ? (usedBackup ? 'backup' : 'ok') : (anyError ? 'down' : 'zero');
    layerStatuses.push({id:def.id, name:def.name, status});
    results.push({def, features:foundFeatures, usedBackup, status});
  }

  presentResults(results, layerStatuses);
}

async function runQueryNearby(){
  if(!STATE.point || !STATE.category){ return; }
  STATE.lastMode = 'nearby';
  const km = Math.max(1, Math.min(200, parseInt(byId('radiusKm').value||'10',10)));
  const m = km * 1000;
  byId('nearbyStatus').textContent = `Consultando radio ${km} km‚Ä¶`;
  clearDrawn();
  byId('results').innerHTML = '';
  byId('mapStatus').textContent = `Buscando cerca (${km} km)‚Ä¶`;

  const layerStatuses = [];
  const results = [];

  for(const def of STATE.defs){
    // expandir y consultar con distancia
    const expanded = await expandToFeatureLayers(def.primary);
    const targetLayers = expanded.layers.length ? expanded.layers : [def.primary];

    let foundFeatures = [];
    let usedBackup = false;
    let anyError = false;

    for(const lyr of targetLayers){
      const r = await queryLayer(lyr, STATE.point, m);
      if(r.error){ anyError = true; continue; }
      if(r.features && r.features.length){ foundFeatures = foundFeatures.concat(r.features.map(ft => ({...ft, _layerUrl: lyr}))); }
    }

    if((!foundFeatures.length || anyError) && def.backup){
      const expB = await expandToFeatureLayers(def.backup);
      const bLayers = expB.layers.length ? expB.layers : [def.backup];
      usedBackup = true;
      anyError = false;
      foundFeatures = [];
      for(const lyr of bLayers){
        const r = await queryLayer(lyr, STATE.point, m);
        if(r.error){ anyError = true; continue; }
        if(r.features && r.features.length){ foundFeatures = foundFeatures.concat(r.features.map(ft => ({...ft, _layerUrl: lyr}))); }
      }
    }

    const status = foundFeatures.length ? (usedBackup ? 'backup' : 'ok') : (anyError ? 'down' : 'zero');
    layerStatuses.push({id:def.id, name:def.name, status});
    results.push({def, features:foundFeatures, usedBackup, status, nearbyKm:km});
  }

  presentResults(results, layerStatuses, true);
  byId('nearbyStatus').textContent = '‚Äî';
}

/* ===== Presentaci√≥n de resultados ===== */
function addLayerToggle(defId, name, status){
  const cont = byId('layerToggles');
  const chip = el('label',{className:'layer-chip'});
  const inp = el('input',{type:'checkbox', checked:true});
  const st = el('span',{className:'badge '+(status==='ok'?'ok':status==='backup'?'backup':status==='down'?'down':'zero')}, status.toUpperCase());
  chip.append(inp, el('span',{}, name), st);
  cont.appendChild(chip);
  inp.addEventListener('change',()=>{
    const layer = STATE.drawn[defId];
    if(!STATE.map || !layer) return;
    if(inp.checked){ layer.addTo(STATE.map); }
    else { STATE.map.removeLayer(layer); }
  });
}

function featuresToGeoJSON(features){
  // Convierte una lista de features ArcGIS a GeoJSON (simple)
  const feats = [];
  for(const f of (features||[])){
    if(!f.geometry) continue;
    // ArcGIS geometries: point, polyline, polygon
    let geom=null;
    if(f.geometry.x!=null && f.geometry.y!=null){
      geom = {type:'Point', coordinates:[f.geometry.x, f.geometry.y]};
    }else if(Array.isArray(f.geometry.paths)){
      // polylines: tomar primer path
      geom = {type:'LineString', coordinates: (f.geometry.paths[0]||[]).map(([x,y])=>[x,y])};
    }else if(Array.isArray(f.geometry.rings)){
      geom = {type:'Polygon', coordinates: [ (f.geometry.rings[0]||[]).map(([x,y])=>[x,y]) ]};
    }
    if(geom){ feats.push({type:'Feature', properties:f.attributes||{}, geometry:geom}); }
  }
  return {type:'FeatureCollection', features:feats};
}

function presentResults(results, layerStatuses, isNearby=false){
  ensureMap();
  const resEl = byId('results');
  resEl.innerHTML = '';

  const found = results.filter(r=> (r.features||[]).length>0);
  const down  = results.filter(r=> r.status==='down');
  const zero  = results.filter(r=> r.status==='zero');

  const msg = [];
  if(found.length){ msg.push(`Se encontraron <b>${found.length}</b> capa(s) con coincidencias ${isNearby?'cerca':'en el punto'}.`); }
  if(zero.length){ msg.push(`<span class=\"small\">${zero.length} capa(s) respondieron sin intersecciones.</span>`); }
  if(down.length){ msg.push(`<span class=\"small\" style=\"color:#f7d38b\">${down.length} capa(s) no disponibles (fuente oficial).</span>`); }
  addBot(msg.join('<br>'));

  // Chips/toggles por capa (solo para las que tienen geometr√≠a dibujable)
  layerStatuses.forEach(s=> addLayerToggle(s.id, s.name, s.status));

  const summaryHits=[];
  results.forEach(({def, features, status, usedBackup}, idx)=>{
    const title = def.name || `Capa ${idx+1}`;
    const count = (features||[]).length;

    const details = el('details');
    details.innerHTML = `<summary>${title}
      <span class="small">(${count} resultado/s${usedBackup?' ‚Äì usando respaldo':''})</span>
      ${status==='ok'?'<span class="badge ok">OK</span>':status==='backup'?'<span class="badge backup">RESPALDO</span>':status==='down'?'<span class="badge down">FUERA DE SERVICIO</span>':'<span class="badge zero">SIN INTERSECCI√ìN</span>'}
    </summary>`;

    // Acceso/Descripci√≥n desde la tabla p√∫blica
    const meta = el('div',{className:'small', style:'margin:6px 0 8px'});
    const acc = def.acceso ? `<a href="${def.acceso}" target="_blank" rel="noopener">acceso</a>` : 'acceso: N/D';
    meta.innerHTML = `${acc} ‚Äî ${def.descripcion||'Sin descripci√≥n'}`;
    details.appendChild(meta);

    (features||[]).forEach((ft,i)=>{
      const attrs = ft.attributes || {};
      const block = el('div',{style:'margin:6px 0'});
      const head  = el('div',{className:'small'}, `#${i+1} ‚Äî atributos`);
      const tbl = el('table'); // toggle simple con <details> anidados
      Object.keys(attrs).forEach(k=>{
        const tr = el('tr'); tr.appendChild(el('td',{}, k)); tr.appendChild(el('td',{}, String(attrs[k]))); tbl.appendChild(tr);
      });
      block.append(head, tbl);
      details.appendChild(block);
    });

    resEl.appendChild(details);

    try{
      const gj = featuresToGeoJSON(features);
      if(gj.features.length){
        const layer = L.geoJSON(gj, {style:()=>({color:'#0a784f', weight:1.1, fillColor:'#0a784f', fillOpacity:.35})});
        layer.addTo(STATE.map);
        STATE.drawn[def.id] = layer;
        summaryHits.push(`${title}: ${count}`);
      }
    }catch{}
  });

  byId('mapStatus').textContent = summaryHits.length? `Capas con resultados ‚Üí ${summaryHits.join(' | ')}` : (isNearby?'Sin intersecciones en el radio.':'Sin intersecciones puntuales.');
}

/* ===== Botones persistentes ===== */
function wireButtons(){
  byId('btnRefresh').onclick = ()=>{ if(STATE.point && STATE.category){ STATE.lastMode==='nearby' ? runQueryNearby() : runQueryPoint(); } };
  byId('btnBackToPoint').onclick = ()=>{ STATE.category=null; STATE.point=null; if(STATE.marker&&STATE.map){STATE.map.removeLayer(STATE.marker); STATE.marker=null;} clearDrawn(); byId('mapWrap').style.display='none'; goToStep(0); };
  byId('btnBackToCategory').onclick = ()=>{ if(STATE.point){ STATE.category=null; clearDrawn(); byId('mapWrap').style.display='none'; goToStep(2);} else { goToStep(0);} };
  byId('fabRefresh').onclick = ()=> restartAll();
  byId('btnNearby').onclick = ()=> runQueryNearby();
}

function restartAll(){
  clearChat();
  byId('results').innerHTML='';
  byId('layerToggles').innerHTML='';
  byId('nearbyBox').style.display='none';
  byId('mapStatus').textContent='‚Äî';
  if(STATE.marker && STATE.map){ STATE.map.removeLayer(STATE.marker); STATE.marker=null; }
  clearDrawn();
  STATE.step=0; STATE.point=null; STATE.category=null; STATE.defs=[]; STATE.lastMode='point';
  byId('mapWrap').style.display='none';
  goToStep(0);
}

/* ===== Init ===== */
(async function init(){
  try{
    await loadCatalog(); computeCategories();
    addBot('Se carg√≥ la tabla p√∫blica con variables y fuentes. Solo se ofrecer√°n categor√≠as con REST/Respaldo disponible.');
    wireButtons();
    goToStep(0);
  }catch(e){
    addBot(`<div class=\"error\">Error al cargar la tabla de variables: ${e.message}. Intenta recargar.</div>`);
  }
})();
</script>
</body>
</html>
